<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/noobcash/api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/noobcash/api.py" />
              <option name="originalContent" value="from flask import Flask, request, jsonify, make_response, Response, render_template&#10;from flask_cors import CORS&#10;from dotenv import load_dotenv&#10;from copy import deepcopy&#10;import os&#10;import argparse&#10;import pickle&#10;import time&#10;import threading&#10;&#10;from src.noobcash.node import Node&#10;from src.noobcash.transaction import Transaction&#10;from src.noobcash.utxo import UTXO&#10;from src.utils.logger import Logger&#10;&#10;# Bootstrap Helper&#10;def check_full_ring(node: Node, total_nodes: int):&#10;    &quot;&quot;&quot;&#10;    Checks if the ring is full and broadcasts the ring, blockchain, and initial NBC if so.&#10;&#10;    :param node: The node instance.&#10;    :param total_nodes: The total number of nodes expected in the network.&#10;    &quot;&quot;&quot;&#10;    time.sleep(1)&#10;    if len(node.ring) == total_nodes:&#10;        node.broadcast_ring()&#10;        node.broadcast_blockchain()&#10;        node.broadcast_initial_nbc()&#10;&#10;def create_genesis_block(node: Node, total_nbc: int):&#10;    &quot;&quot;&quot;&#10;    Create the first block of the blockchain (GENESIS BLOCK).&#10;    Accepts the node and total initial NBCs to credit.&#10;&#10;    :param node: The node instance.&#10;    :param total_nbc: The total amount of NoobCoins to be distributed.&#10;    &quot;&quot;&quot;&#10;    gen_block = node.create_new_block()  # previous_hash autogenerates&#10;    gen_block.nonce = 0&#10;&#10;    first_transaction = Transaction(&#10;        sender_address='0',&#10;        sender_private_key=None,&#10;        receiver_address=node.wallet.address,&#10;        value=total_nbc&#10;    )&#10;&#10;    gen_block.transactions_list.append(first_transaction)&#10;    gen_block.calculate_hash()&#10;&#10;    node.blockchain.chain.append(gen_block)&#10;    # Add first UTXO - keep existing indexing scheme&#10;    node.blockchain.UTXOs[0].append(UTXO(-1, node.id, total_nbc))&#10;&#10;    node.current_block = node.create_new_block()&#10;&#10;def init_node(args):&#10;    &quot;&quot;&quot;&#10;    Initialize Node object, environment and bootstrap logic.&#10;    Returns (node, total_nodes, total_nbc, bootstrap_node, ip_address, port).&#10;&#10;    :param args: Command line arguments.&#10;    :return: A tuple containing the initialized node, total nodes, total NBC, bootstrap node info, IP address, and port.&#10;    &quot;&quot;&quot;&#10;&#10;    total_nodes = args.total_nodes&#10;    total_nbc = total_nodes * 100&#10;&#10;    load_dotenv()&#10;    node = Node(total_nodes)&#10;&#10;    bootstrap_node = {&#10;        'ip': os.getenv('API_IP'),&#10;        'port': os.getenv('BOOTSTRAP_PORT')&#10;    }&#10;&#10;    ip_address = args.ip&#10;    port = args.port&#10;&#10;    node.ip = ip_address&#10;    node.port = str(port)&#10;&#10;    # See if node is Bootstrap node&#10;    if ip_address == bootstrap_node[&quot;ip&quot;] and str(port) == bootstrap_node[&quot;port&quot;]:&#10;        node.is_bootstrap = True&#10;&#10;    # Register node to the cluster&#10;    if node.is_bootstrap:&#10;        node.id = 0&#10;        Logger.info(&quot;I am bootstrap&quot;)&#10;        node.add_node_to_ring(node.id, node.ip, node.port, node.wallet.address, total_nbc)&#10;        create_genesis_block(node, total_nbc)&#10;    else:&#10;        node.unicast_node(bootstrap_node)&#10;&#10;    return node, total_nodes, total_nbc, bootstrap_node, ip_address, port&#10;&#10;&#10;# App Factory&#10;def create_app(node: Node, total_nodes: int, total_nbc: int):&#10;    &quot;&quot;&quot;&#10;    Create and return Flask app with routes bound to the provided node.&#10;&#10;    :param node: The node instance.&#10;    :param total_nodes: The total number of nodes in the network.&#10;    :param total_nbc: The total amount of NoobCoins.&#10;    :return: The Flask application instance.&#10;    &quot;&quot;&quot;&#10;    app = Flask(__name__)&#10;    CORS(app, resources={r&quot;/*&quot;: {&quot;origins&quot;: &quot;*&quot;}})&#10;&#10;    @app.route(&quot;/api/create_transaction/&lt;int:receiver_id&gt;/&lt;int:amount&gt;&quot;, methods=['GET'])&#10;    def create_transaction(receiver_id: int, amount: int):&#10;        if receiver_id &gt;= total_nodes:&#10;            return make_response(jsonify({&quot;message&quot;: 'Node ID does not exist'}), 400)&#10;&#10;        receiver_address = list(node.ring.keys())[receiver_id]&#10;        transaction = node.create_transaction(receiver_address, amount)&#10;        node.add_transaction_to_pending(transaction)&#10;        node.broadcast_transaction(transaction)&#10;        return make_response(jsonify({'message': 'Successful Transaction !'}), 200)&#10;&#10;    @app.route(&quot;/api/view_transactions&quot;, methods=['GET'])&#10;    def view_transactions():&#10;        if len(node.blockchain.chain) &lt;= 1:&#10;            return jsonify('There are no mined blocks at the moment !')&#10;&#10;        latest_block = node.blockchain.chain[-1]&#10;        transactions = []&#10;        for transaction in latest_block.transactions_list:&#10;            transactions.append({&#10;                &quot;sender_id&quot;: node.ring[transaction.sender_address]['id'],&#10;                &quot;receiver_id&quot;: node.ring[transaction.receiver_address]['id'],&#10;                &quot;amount&quot;: transaction.amount&#10;            })&#10;&#10;        return make_response(jsonify(transactions), 200)&#10;&#10;    @app.route(&quot;/api/get_balance&quot;, methods=['GET'])&#10;    def get_balance():&#10;        balance = node.ring[node.wallet.address]['balance']&#10;        return make_response(jsonify({'balance': balance}), 200)&#10;&#10;    @app.route(&quot;/api/get_chain_length&quot;, methods=['GET'])&#10;    def get_chain_length():&#10;        chain_len = len(node.blockchain.chain)&#10;        return make_response(jsonify({'chain_length': chain_len}), 200)&#10;&#10;    @app.route(&quot;/api/get_chain&quot;, methods=['GET'])&#10;    def get_chain():&#10;        return Response(pickle.dumps(node.blockchain), mimetype='application/octet-stream')&#10;&#10;    @app.route(&quot;/api/node_info&quot;, methods=['GET'])&#10;    def get_node_info():&#10;        return make_response(jsonify({&#10;            'id': node.id,&#10;            'ip': node.ip,&#10;            'port': node.port,&#10;            'address': node.wallet.address,&#10;            'balance': node.ring[node.wallet.address]['balance'] if node.wallet.address in node.ring else 0&#10;        }), 200)&#10;&#10;    # INTERNAL ROUTES&#10;    @app.route(&quot;/&quot;, methods=['GET'])&#10;    def root():&#10;        return render_template('index.html')&#10;&#10;    @app.route(&quot;/get_ring&quot;, methods=['POST'])&#10;    def get_ring():&#10;        data = request.data&#10;        node.ring = pickle.loads(data)&#10;        Logger.success(&quot;Ring received successfully !&quot;)&#10;        return make_response('OK', 200)&#10;&#10;    @app.route(&quot;/get_blockchain&quot;, methods=['POST'])&#10;    def get_blockchain():&#10;        data = request.data&#10;        node.blockchain = pickle.loads(data)&#10;        node.temp_utxos = deepcopy(node.blockchain.UTXOs)&#10;        Logger.success(&quot;Blockchain received successfully !&quot;)&#10;        return make_response('OK', 200)&#10;&#10;    @app.route(&quot;/get_transaction&quot;, methods=['POST'])&#10;    def get_transaction():&#10;        data = request.data&#10;        new_transaction = pickle.loads(data)&#10;        Logger.info(&quot;New transaction received successfully !&quot;)&#10;        node.add_transaction_to_pending(new_transaction)&#10;        return make_response('OK', 200)&#10;&#10;    @app.route(&quot;/get_block&quot;, methods=['POST'])&#10;    def get_block():&#10;        data = request.data&#10;        new_block = pickle.loads(data)&#10;        Logger.info(&quot;New block received successfully !&quot;)&#10;&#10;        def process_incoming_block(block):&#10;            with node.processing_block_lock:&#10;                if block.validate_block(node.blockchain):&#10;                    with node.incoming_block_lock:&#10;                        node.incoming_block = True&#10;                    Logger.mining(&quot;Block was mined by someone else&quot;)&#10;                    Logger.success(&quot;Adding it to the chain&quot;)&#10;                    node.add_block_to_chain(block)&#10;                    Logger.info(f&quot;Blockchain length: {len(node.blockchain.chain)}&quot;)&#10;                elif node.blockchain.chain[-1].previous_hash == block.previous_hash:&#10;                    Logger.warning(&quot;Rejected incoming block&quot;)&#10;                else:&#10;                    Logger.warning(f&quot;Incoming block previous_hash: {block.previous_hash}&quot;)&#10;                    Logger.info(&quot;BLOCKCHAIN&quot;)&#10;                    Logger.info(str([block.hash[:7] for block in node.blockchain.chain]))&#10;                    node.blockchain.resolve_conflict(node)&#10;                    Logger.error(&quot;Something went wrong with validation&quot;)&#10;&#10;        # Process block in a separate thread to avoid timeouts on the sender side&#10;        t = threading.Thread(target=process_incoming_block, args=(new_block,))&#10;        t.start()&#10;&#10;        return make_response('OK', 200)&#10;&#10;    @app.route(&quot;/let_me_in&quot;, methods=['POST'])&#10;    def let_me_in():&#10;        ip = request.form.get('ip')&#10;        port_form = request.form.get('port')&#10;        address = request.form.get('address')&#10;        id = len(node.ring)&#10;&#10;        node.add_node_to_ring(id, ip, port_form, address, 0)&#10;&#10;        t = threading.Thread(&#10;            target=check_full_ring,&#10;            args=(node, total_nodes),&#10;            name=&quot;BootstrapRingCheckerThread&quot;&#10;        )&#10;        t.start()&#10;&#10;        return make_response(jsonify({'id': id}), 200)&#10;&#10;    return app&#10;&#10;# Entrypoint&#10;def main():&#10;    parser = argparse.ArgumentParser()&#10;    parser.add_argument(&quot;-p&quot;, &quot;--port&quot;, help=&quot;Port in which node is running&quot;, default=8000, type=int)&#10;    parser.add_argument(&quot;--ip&quot;, help=&quot;IP of the host&quot;, default=&quot;127.0.0.1&quot;)&#10;    parser.add_argument(&quot;--total_nodes&quot;, help=&quot;Total number of nodes in the network&quot;, default=5, type=int)&#10;&#10;    args = parser.parse_args()&#10;&#10;    node, total_nodes, total_nbc, bootstrap_node, ip_address, port = init_node(args)&#10;    app = create_app(node, total_nodes, total_nbc)&#10;&#10;    app.run(host=ip_address, port=port)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="from flask import Flask, request, jsonify, make_response, Response, render_template&#10;from flask_cors import CORS&#10;from dotenv import load_dotenv&#10;from copy import deepcopy&#10;import os&#10;import argparse&#10;import pickle&#10;import time&#10;import threading&#10;&#10;from src.noobcash.node import Node&#10;from src.noobcash.transaction import Transaction&#10;from src.noobcash.utxo import UTXO&#10;from src.utils.logger import Logger&#10;&#10;# Bootstrap Helper&#10;def check_full_ring(node: Node, total_nodes: int):&#10;    &quot;&quot;&quot;&#10;    Checks if the ring is full and broadcasts the ring, blockchain, and initial NBC if so.&#10;&#10;    :param node: The node instance.&#10;    :param total_nodes: The total number of nodes expected in the network.&#10;    &quot;&quot;&quot;&#10;    time.sleep(1)&#10;    if len(node.ring) == total_nodes:&#10;        node.broadcast_ring()&#10;        node.broadcast_blockchain()&#10;        node.broadcast_initial_nbc()&#10;&#10;def create_genesis_block(node: Node, total_nbc: int):&#10;    &quot;&quot;&quot;&#10;    Create the first block of the blockchain (GENESIS BLOCK).&#10;    Accepts the node and total initial NBCs to credit.&#10;&#10;    :param node: The node instance.&#10;    :param total_nbc: The total amount of NoobCoins to be distributed.&#10;    &quot;&quot;&quot;&#10;    gen_block = node.create_new_block()  # previous_hash autogenerates&#10;    gen_block.nonce = 0&#10;&#10;    first_transaction = Transaction(&#10;        sender_address='0',&#10;        sender_private_key=None,&#10;        receiver_address=node.wallet.address,&#10;        value=total_nbc&#10;    )&#10;&#10;    gen_block.transactions_list.append(first_transaction)&#10;    gen_block.calculate_hash()&#10;&#10;    node.blockchain.chain.append(gen_block)&#10;    # Add first UTXO - keep existing indexing scheme&#10;    node.blockchain.UTXOs[0].append(UTXO(-1, node.id, total_nbc))&#10;&#10;    node.current_block = node.create_new_block()&#10;&#10;def init_node(args):&#10;    &quot;&quot;&quot;&#10;    Initialize Node object, environment and bootstrap logic.&#10;    Returns (node, total_nodes, total_nbc, bootstrap_node, ip_address, port).&#10;&#10;    :param args: Command line arguments.&#10;    :return: A tuple containing the initialized node, total nodes, total NBC, bootstrap node info, IP address, and port.&#10;    &quot;&quot;&quot;&#10;&#10;    total_nodes = args.total_nodes&#10;    total_nbc = total_nodes * 100&#10;&#10;    load_dotenv()&#10;    node = Node(total_nodes)&#10;&#10;    bootstrap_node = {&#10;        'ip': os.getenv('API_IP'),&#10;        'port': os.getenv('BOOTSTRAP_PORT')&#10;    }&#10;&#10;    ip_address = args.ip&#10;    port = args.port&#10;&#10;    node.ip = ip_address&#10;    node.port = str(port)&#10;&#10;    # See if node is Bootstrap node&#10;    if ip_address == bootstrap_node[&quot;ip&quot;] and str(port) == bootstrap_node[&quot;port&quot;]:&#10;        node.is_bootstrap = True&#10;&#10;    # Register node to the cluster&#10;    if node.is_bootstrap:&#10;        node.id = 0&#10;        Logger.info(&quot;I am bootstrap&quot;)&#10;        node.add_node_to_ring(node.id, node.ip, node.port, node.wallet.address, total_nbc)&#10;        create_genesis_block(node, total_nbc)&#10;    else:&#10;        node.unicast_node(bootstrap_node)&#10;&#10;    return node, total_nodes, total_nbc, bootstrap_node, ip_address, port&#10;&#10;&#10;# App Factory&#10;def create_app(node: Node, total_nodes: int, total_nbc: int):&#10;    &quot;&quot;&quot;&#10;    Create and return Flask app with routes bound to the provided node.&#10;&#10;    :param node: The node instance.&#10;    :param total_nodes: The total number of nodes in the network.&#10;    :param total_nbc: The total amount of NoobCoins.&#10;    :return: The Flask application instance.&#10;    &quot;&quot;&quot;&#10;    app = Flask(__name__)&#10;    CORS(app, resources={r&quot;/*&quot;: {&quot;origins&quot;: &quot;*&quot;}})&#10;&#10;    @app.route(&quot;/api/create_transaction/&lt;int:receiver_id&gt;/&lt;int:amount&gt;&quot;, methods=['GET'])&#10;    def create_transaction(receiver_id: int, amount: int):&#10;        if receiver_id &gt;= total_nodes:&#10;            return make_response(jsonify({&quot;message&quot;: 'Node ID does not exist'}), 400)&#10;&#10;        receiver_address = list(node.ring.keys())[receiver_id]&#10;        transaction = node.create_transaction(receiver_address, amount)&#10;        node.add_transaction_to_pending(transaction)&#10;        node.broadcast_transaction(transaction)&#10;        return make_response(jsonify({'message': 'Successful Transaction !'}), 200)&#10;&#10;    @app.route(&quot;/api/view_transactions&quot;, methods=['GET'])&#10;    def view_transactions():&#10;        if len(node.blockchain.chain) &lt;= 1:&#10;            return jsonify('There are no mined blocks at the moment !')&#10;&#10;        latest_block = node.blockchain.chain[-1]&#10;        transactions = []&#10;        for transaction in latest_block.transactions_list:&#10;            transactions.append({&#10;                &quot;sender_id&quot;: node.ring[transaction.sender_address]['id'],&#10;                &quot;receiver_id&quot;: node.ring[transaction.receiver_address]['id'],&#10;                &quot;amount&quot;: transaction.amount&#10;            })&#10;&#10;        return make_response(jsonify(transactions), 200)&#10;&#10;    @app.route(&quot;/api/get_balance&quot;, methods=['GET'])&#10;    def get_balance():&#10;        balance = node.ring[node.wallet.address]['balance']&#10;        return make_response(jsonify({'balance': balance}), 200)&#10;&#10;    @app.route(&quot;/api/get_chain_length&quot;, methods=['GET'])&#10;    def get_chain_length():&#10;        chain_len = len(node.blockchain.chain)&#10;        return make_response(jsonify({'chain_length': chain_len}), 200)&#10;&#10;    @app.route(&quot;/api/get_chain&quot;, methods=['GET'])&#10;    def get_chain():&#10;        return Response(pickle.dumps(node.blockchain), mimetype='application/octet-stream')&#10;&#10;    @app.route(&quot;/api/node_info&quot;, methods=['GET'])&#10;    def get_node_info():&#10;        return make_response(jsonify({&#10;            'id': node.id,&#10;            'ip': node.ip,&#10;            'port': node.port,&#10;            'address': node.wallet.address,&#10;            'balance': node.ring[node.wallet.address]['balance'] if node.wallet.address in node.ring else 0&#10;        }), 200)&#10;&#10;    # INTERNAL ROUTES&#10;    @app.route(&quot;/&quot;, methods=['GET'])&#10;    def root():&#10;        return render_template('index.html')&#10;&#10;    @app.route(&quot;/get_ring&quot;, methods=['POST'])&#10;    def get_ring():&#10;        data = request.data&#10;        node.ring = pickle.loads(data)&#10;        Logger.success(&quot;Ring received successfully !&quot;)&#10;        return make_response('OK', 200)&#10;&#10;    @app.route(&quot;/get_blockchain&quot;, methods=['POST'])&#10;    def get_blockchain():&#10;        data = request.data&#10;        node.blockchain = pickle.loads(data)&#10;        node.temp_utxos = deepcopy(node.blockchain.UTXOs)&#10;        Logger.success(&quot;Blockchain received successfully !&quot;)&#10;        return make_response('OK', 200)&#10;&#10;    @app.route(&quot;/get_transaction&quot;, methods=['POST'])&#10;    def get_transaction():&#10;        data = request.data&#10;        new_transaction = pickle.loads(data)&#10;        Logger.info(&quot;New transaction received successfully !&quot;)&#10;        node.add_transaction_to_pending(new_transaction)&#10;        return make_response('OK', 200)&#10;&#10;    @app.route(&quot;/get_block&quot;, methods=['POST'])&#10;    def get_block():&#10;        data = request.data&#10;        new_block = pickle.loads(data)&#10;        Logger.info(&quot;New block received successfully !&quot;)&#10;&#10;        def process_incoming_block(block):&#10;            with node.processing_block_lock:&#10;                if block.validate_block(node.blockchain):&#10;                    with node.incoming_block_lock:&#10;                        node.incoming_block = True&#10;                    Logger.mining(&quot;Block was mined by someone else&quot;)&#10;                    Logger.success(&quot;Adding it to the chain&quot;)&#10;                    node.add_block_to_chain(block)&#10;                    Logger.info(f&quot;Blockchain length: {len(node.blockchain.chain)}&quot;)&#10;                elif node.blockchain.chain[-1].previous_hash == block.previous_hash:&#10;                    Logger.warning(&quot;Rejected incoming block&quot;)&#10;                else:&#10;                    Logger.warning(f&quot;Incoming block previous_hash: {block.previous_hash}&quot;)&#10;                    Logger.info(&quot;BLOCKCHAIN&quot;)&#10;                    Logger.info(str([block.hash[:7] for block in node.blockchain.chain]))&#10;                    node.blockchain.resolve_conflict(node)&#10;                    Logger.error(&quot;Something went wrong with validation&quot;)&#10;&#10;        # Process block in a separate thread to avoid timeouts on the sender side&#10;        t = threading.Thread(target=process_incoming_block, args=(new_block,))&#10;        t.start()&#10;&#10;        return make_response('OK', 200)&#10;&#10;    @app.route(&quot;/let_me_in&quot;, methods=['POST'])&#10;    def let_me_in():&#10;        ip = request.form.get('ip')&#10;        port_form = request.form.get('port')&#10;        address = request.form.get('address')&#10;        id = len(node.ring)&#10;&#10;        node.add_node_to_ring(id, ip, port_form, address, 0)&#10;&#10;        t = threading.Thread(&#10;            target=check_full_ring,&#10;            args=(node, total_nodes),&#10;            name=&quot;BootstrapRingCheckerThread&quot;&#10;        )&#10;        t.start()&#10;&#10;        return make_response(jsonify({'id': id}), 200)&#10;&#10;    return app&#10;&#10;# Entrypoint&#10;def main():&#10;    parser = argparse.ArgumentParser()&#10;    parser.add_argument(&quot;-p&quot;, &quot;--port&quot;, help=&quot;Port in which node is running&quot;, default=8000, type=int)&#10;    parser.add_argument(&quot;--ip&quot;, help=&quot;IP of the host&quot;, default=&quot;127.0.0.1&quot;)&#10;    parser.add_argument(&quot;--total_nodes&quot;, help=&quot;Total number of nodes in the network&quot;, default=5, type=int)&#10;&#10;    args = parser.parse_args()&#10;&#10;    node, total_nodes, total_nbc, bootstrap_node, ip_address, port = init_node(args)&#10;    app = create_app(node, total_nodes, total_nbc)&#10;&#10;    app.run(host=ip_address, port=port)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>